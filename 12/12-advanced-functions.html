<!DOCTYPE html>
<html>
  <head> 
    <title>Advanced functions</title> <!-- sets the text in the tab heading -->
      <style> 
  
      </style> 
  </head>
  <body> 
    <button onclick="" class="js-button">Click</button>
    <script>
      const buttonElement = document.querySelector('.js-button');

      /*

      //*****addEventListener takes into parameters******
      //param1 = event that function listens for (specific names)
      //param2 = function we want to run after clicking button
      const eventListener = () => {
        console.log('click1');
      }
      buttonElement.addEventListener('click', eventListener);
      //advantage: we can add/remove multiple event listeners 
      buttonElement.addEventListener('click', ()=>{
        console.log('click2');
      }); 

      //******removeEventListener takes in two parameters******
      //param1 = event 
      //param2 = function that we want to remove
      buttonElement.removeEventListener('click', eventListener);

      */


      /*
      function greeting(){
        console.log('Hello');
      }
      //this type of function has a hositing advantage
      //hosting - you are able to call the function before it is written and declared 
      //hoisting doesn't work when the function is stored in a variable
      greeting();

      //Saving functions inside a variable 
      const f1 = function greeting(){
        console.log('hello2');
      };

      console.log(f1);
      console.log(typeof f1); //function
      //running a function stored inside a variable
      f1();

      //we can also save functions (value) inside objects
      const object1 = {
        num: 2,
        f: function greeting(){
          console.log('hello3');
        }
      };

      object1.f(); //dot notation and ( ) to access and call function
      //functions saved inside objects are called method
      
      function display(parameter){
        console.log(parameter);
      }

      display(2);
      //display(object1.f());

      function run(parameter){ //passing a function into another function
        parameter(); 
      }

      run(function() {
        console.log('hello4');
      });*/

      //------****** SET TIMEOUT ******------
      //runs a function at a future time
      //first parameter is the function we want to run in the future
      //second paramter is the delay time (in milliseconds) before running function 
      /*setTimeout(function(){
        console.log('timeout');
        console.log('timeout2');
      }, 3000); 
      console.log('next line')
      //asynchronous: computer does not wait for the delay, proceeds straight to next line 
      //synchronous: computer waits for a line to finish running before proceeding

      //------****** SET INTERVAL ******------
      //will keep running a function every set amount of delay time
      //first parameter is the function we want to run in the future
      //second paramter is the delay time (in milliseconds) before running function 
      setInterval(function(){
        console.log('interval');
      }, 3000);

      console.log('next line 2');*/

      /*const array0 = [
        'make dinner',  
        'wash dishes',
        'watch youtube'
      ]
      array0.forEach(function(value, index){
        if (value === 'wash dishes'){
          return; 
        }
        console.log(`index: ${index} - ${value}`);
      })

      //if you need to break out of a loop, use regular for loop instead of a for each

      const arrowFunctionSlow = function(param1, param2){
        console.log('hello - slow')
        return 5;
      }

      const arrowFunctionExpress = (param1, param2) => {
        console.log('hello - express');
        return 5;
      };

      arrowFunctionSlow();
      arrowFunctionExpress();
      
      const oneParam = (param) => {
        console.log(param+1);
      }
      oneParam(2);

      const oneLine = () => 2 + 3 ;
      //automatically returns the value of the expression to the right of arrow
      console.log(oneLine());

      array0.forEach((value, index) => {
        if (value === 'wash dishes'){
          return; 
        }
        console.log(`index: ${index} - ${value} (using arrow function)`);
        
      })

      const object2 = {
        methodArrowFunction: () => {

        },
        methodShorthand(){

        }
      }*/

      [1, 2, 3].forEach((value, index) => {
        console.log(value);
      });

      //.filter()
      //creates a new, empty array
      //if the inner function returns true, value is added
      console.log([1, -3, 5].filter((value, index) => {
        if (value >= 0){
          return true;
        }
        return false;
      }));

      //.map() 
      //creates a new array[]
      //whatever is returned is added to new array
      console.log([1, 1, 3].map((value, index) => {
        return value*2;
      }));

      console.log([1, 1, 3].map((value, index) => value*2));

      //closure 
      //if a function has access to a value, it will always have access to the value
      //value is packaged together with the function 
    </script>
  </body>
</html>





